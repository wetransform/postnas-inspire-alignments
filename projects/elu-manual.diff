diff --git a/projects/elu-auto.halex.alignment.xml b/projects/elu-manual.halex.alignment.xml
index f0a1c66..ccb667f 100644
--- a/projects/elu-auto.halex.alignment.xml
+++ b/projects/elu-manual.halex.alignment.xml
@@ -64,11 +64,22 @@ Nur erfolgreich falls genau eine Simple Feature Geometrie gebildet werden kann.
     </customFunction>
     <customFunction>
         <cf:custom-property-function xmlns:cf="http://www.esdi-humboldt.eu/hale/custom-function" identifier="adv.inspire.AX_Lagebezeichnung.GeographicalName" name="AX_Lagebezeichnung zu GeographicalName" type="groovy">
-            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lagebezeichnung">
+            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lage_unverschluesselt">
                 <cf:binding>java.lang.String</cf:binding>
-                <cf:type name="AX_LagebezeichnungType" ns="http://www.adv-online.de/namespaces/adv/gid/7.1"/>
             </cf:input>
-            <cf:input eager="false" maxOccurs="1" minOccurs="0" name="source">
+            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lage_land">
+                <cf:binding>java.lang.String</cf:binding>
+            </cf:input>
+            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lage_regierungsbezirk">
+                <cf:binding>java.lang.String</cf:binding>
+            </cf:input>
+            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lage_kreis">
+                <cf:binding>java.lang.String</cf:binding>
+            </cf:input>
+            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lage_gemeinde">
+                <cf:binding>java.lang.String</cf:binding>
+            </cf:input>
+            <cf:input eager="false" maxOccurs="1" minOccurs="1" name="lage_lage">
                 <cf:binding>java.lang.String</cf:binding>
             </cf:input>
             <cf:output eager="false" maxOccurs="1" minOccurs="1"/>
@@ -103,16 +114,16 @@ Nur erfolgreich falls genau eine Simple Feature Geometrie gebildet werden kann.
             </cf:param>
             <cf:definition>
                 <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-def name = lagebezeichnung.p.unverschluesselt.value()
+def name = lage_unverschluesselt
 
 if (!name) {
 	// Namen auch aus verschlüsselter Lagebezeichnung ableiten
 	
-	def gemeinde = lagebezeichnung.p.verschluesselt.AX_VerschluesselteLagebezeichnung.gemeinde.value()
-	def kreis = lagebezeichnung.p.verschluesselt.AX_VerschluesselteLagebezeichnung.kreis.value()
-	def lage = lagebezeichnung.p.verschluesselt.AX_VerschluesselteLagebezeichnung.lage.value()
-	def land = lagebezeichnung.p.verschluesselt.AX_VerschluesselteLagebezeichnung.land.value()
-	def reg = lagebezeichnung.p.verschluesselt.AX_VerschluesselteLagebezeichnung.regierungsbezirk.value()
+	def gemeinde = lage_gemeinde
+	def kreis = lage_kreis
+	def lage = lage_lage
+	def land = lage_land
+	def reg = lage_regierungsbezirk
 
 	if (land &amp;&amp; gemeinde &amp;&amp; kreis &amp;&amp; lage) {
 		if (!reg) reg = '0'
@@ -277,7 +288,6 @@ if (_params.source) {&#13;&#13;
             </cf:input>
             <cf:input eager="true" maxOccurs="1" minOccurs="0" name="source">
                 <cf:binding>java.lang.String</cf:binding>
-                <cf:type name="AA_ModellartPropertyType" ns="http://www.adv-online.de/namespaces/adv/gid/7.1"/>
             </cf:input>
             <cf:output eager="false" maxOccurs="1" minOccurs="1"/>
             <cf:param maxOccurs="1" minOccurs="0" name="source">
@@ -2197,7 +2207,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2242,7 +2252,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2269,7 +2279,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2314,7 +2324,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2341,7 +2351,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2386,7 +2396,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2413,7 +2423,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2458,7 +2468,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2485,7 +2495,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2530,7 +2540,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2557,7 +2567,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2602,7 +2612,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2629,7 +2639,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2674,7 +2684,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2701,7 +2711,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2746,7 +2756,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2773,7 +2783,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2818,7 +2828,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2845,7 +2855,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2890,7 +2900,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2917,7 +2927,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -2962,7 +2972,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -2989,7 +2999,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3034,7 +3044,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3061,7 +3071,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3106,7 +3116,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3133,7 +3143,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3178,7 +3188,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3205,7 +3215,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3250,7 +3260,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3277,7 +3287,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3322,7 +3332,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3349,7 +3359,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3394,7 +3404,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3421,7 +3431,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3466,7 +3476,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3493,7 +3503,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3538,7 +3548,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3565,7 +3575,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3610,7 +3620,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3637,7 +3647,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3682,7 +3692,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3709,7 +3719,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3754,7 +3764,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3781,7 +3791,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3826,7 +3836,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3853,7 +3863,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3898,7 +3908,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3925,7 +3935,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -3970,7 +3980,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -3997,7 +4007,7 @@ import com.vividsolutions.jts.geom.Geometry&#13;
 &#13;
 def c = _.context.collector()&#13;
 &#13;
-def geom = _.geom.find(position.p.first())&#13;
+def geom = _.geom.find(wkb_geometry)&#13;
 if (!geom) {&#13;
   _log.error('No geometry found')&#13;
   return&#13;
@@ -4042,7 +4052,7 @@ return targeom
         <documentation>Mapping auf Ebene von AX_Tatsaechliche Nutzung, weil alle verwendeten FeatureTypes davon abgeleitet sind.&#13;
 Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer niedriger Priorisierten Zelle zur Erzeugung des ExistingLandUseDataSets für den extent genutzt wird. Bei dem Mapping jeder Geometrie wird eine BoundingBox von der bisher im Collector enthaltenen BoundingBox und der neuen Geometrie gebildet und diese neu gebildete BoundingBox in den Collector geschrieben</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -5054,7 +5064,7 @@ Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer
         <parameter value="null" name="notClassifiedAction"/>
         <documentation>Ob die Klassifikation der Werte in foerdergut, lagergut und primaerenergie vorgenommen werden muss, hängt vom Wert in Funktion ab. Da höchstens einer der drei Fälle eintreten kann, können diese mit der gleichen Priorisierung vorgenommen werden.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">Filter condition may not be valid because the entity it is applied to has been replaced</core:text>
                 </core:content>
@@ -5380,7 +5390,7 @@ Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer
         <parameter value="null" name="notClassifiedAction"/>
         <documentation>Ob die Klassifikation der Werte in foerdergut, lagergut und primaerenergie vorgenommen werden muss, hängt vom Wert in Funktion ab. Da höchstens einer der drei Fälle eintreten kann, können diese mit der gleichen Priorisierung vorgenommen werden.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">Filter condition may not be valid because the entity it is applied to has been replaced</core:text>
                 </core:content>
@@ -5454,7 +5464,7 @@ Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer
         <parameter value="null" name="notClassifiedAction"/>
         <documentation>Ob die Klassifikation der Werte in foerdergut, lagergut und primaerenergie vorgenommen werden muss, hängt vom Wert in Funktion ab. Da höchstens einer der drei Fälle eintreten kann, können diese mit der gleichen Priorisierung vorgenommen werden.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">Filter condition may not be valid because the entity it is applied to has been replaced</core:text>
                 </core:content>
@@ -6516,7 +6526,7 @@ Groovy-Script bildet BoundingBox von allen verwendeten Geometrien, die in einer
         </complexParameter>
         <parameter value="null" name="notClassifiedAction"/>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">Filter condition may not be valid because the entity it is applied to has been replaced</core:text>
                 </core:content>
@@ -8094,14 +8104,14 @@ Groovy-Funktion genutzt, um alle erzeugten localIds in einem Kollektor zu sammel
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8110,7 +8120,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8132,14 +8142,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8148,7 +8158,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8170,14 +8180,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8186,7 +8196,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8208,14 +8218,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8224,7 +8234,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8246,14 +8256,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8262,7 +8272,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8284,14 +8294,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8300,7 +8310,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8322,14 +8332,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8338,7 +8348,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8360,14 +8370,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8376,7 +8386,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8398,14 +8408,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8414,7 +8424,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8436,14 +8446,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8452,7 +8462,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8474,14 +8484,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8490,7 +8500,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8512,14 +8522,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8528,7 +8538,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8550,14 +8560,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8566,7 +8576,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8588,14 +8598,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8604,7 +8614,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8626,14 +8636,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8642,7 +8652,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8664,14 +8674,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8680,7 +8690,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8702,14 +8712,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8718,7 +8728,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8740,14 +8750,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8756,7 +8766,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8778,14 +8788,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8794,7 +8804,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8816,14 +8826,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8832,7 +8842,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8854,14 +8864,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8870,7 +8880,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8892,14 +8902,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8908,7 +8918,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8930,14 +8940,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8946,7 +8956,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -8968,14 +8978,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -8984,7 +8994,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -9006,14 +9016,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -9022,7 +9032,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
@@ -9044,14 +9054,14 @@ Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observation
         </target>
         <complexParameter name="script">
             <core:text xmlns:core="http://www.esdi-humboldt.eu/hale/core" xml:space="preserve">
-if (!datumDerLetztenUeberpruefung) {&#13;
+if (!datumderletztenueberpruefung) {&#13;
 	_target {&#13;
 		nilReason( _project.vars.VOID_REASON_OBSERVATIONDATE )&#13;
 	}&#13;
 }&#13;
 &#13;
 else {&#13;
-	_target (datumDerLetztenUeberpruefung)&#13;
+	_target (new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).parse(datumderletztenueberpruefung))&#13;
 }
 </core:text>
         </complexParameter>
@@ -9060,7 +9070,7 @@ else {&#13;
 Der nilReason wird abhängig von der Angabe in der Projektvariablen gefüllt.  Eingabe von "other:unpopulated" für alle ATKIS-Datensätze und solche ALKIS-Datensätze, in denen datumDerLetztenUeberpruefung nie gefüllt ist, Eingabe von "unknown" für ALKIS-Datensätze, in denen es manchmal gefüllt ist.&#13;
 Liegt ein Wert für datumDerLetztenUeberpruefung vor, wird dieser in observationDate geschrieben.</documentation>
         <annotation type="message">
-            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration">
+            <core:message xmlns:core="http://www.esdi-humboldt.eu/hale/core" category="migration" dismissed="true">
                 <core:content>
                     <core:text xml:space="preserve">The cell's source entities have been replaced, the new entities may have a different structure and/or names and may require updating the Groovy script accordingly</core:text>
                 </core:content>
